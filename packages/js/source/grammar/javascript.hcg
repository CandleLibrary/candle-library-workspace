@IGNORE g:sp g:nl tk:comment

@IMPORT default-productions as def

@EXPORT javascript as js
@EXPORT expression as exp
@EXPORT statement_list_item as stmt

####################

f:BindingExpression { { t_BindingExpression, symbol:"=", declaration:$1, initializer:$2,  tok  } }

f:Spread{ { t_Spread, expression:$2,  tok  } }

######################################################################p#########################################
###############################################################################################################
###############################################################################################################
# Productions
###############################################################################################################
###############################################################################################################
###############################################################################################################

<> javascript > module                                                                                                  
                                                    f:r { { t_Module, statements:$1, tok  } }

###############################################################################################################
###############################################################################################################
## SCRIPT
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-ecmascript-language-scripts-and-modules
###############################################################################################################

<> script > script_body                                                                                     
                                                    f:r { { t_Script, statements:$1, tok } }

<> script_body > statement_list      

### Meta

<> comment > \/* ( g:sp | g:nl | g:id | g:num | g:sym )(*) \*/
    | \// ( g:sp | g:id | g:num | g:sym )(*) ( g:nl | ?=$eof ) 


###############################################################################################################
###############################################################################################################
## MODULES
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-ecmascript-language-scripts-and-modules
###############################################################################################################

<> module > module_body      

<> module_body > module_item(+)                                                                         

<> module_item > import_declaration
    | export_declaration
    | statement_list_item

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-ImportDeclaration
###############################################################################################################

<> import_declaration > t:import import_clause from_clause asi                                              
                                                    f:r { { t_ImportDeclaration, clause:$2, from:$3, tok } }
    | t:import string_literal asi                                                                             
                                                    f:r { { t_ImportDeclaration, from:$2, tok } }

<> import_clause > imported_default_binding                                                                 
                                                    f:r { [$1] }
    | namespace                                                                                         
                                                    f:r { [$1] }
    | specifier_clause 

    | imported_default_binding , namespace                                                              
                                                    f:r { [$1, $3] }
    | imported_default_binding , specifier_clause                                                                  
                                                    f:r { [$1] + $3 }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-exports
###############################################################################################################

<> export_declaration > t:export ( namespace | \* f:r { null } ) from_clause asi 

                                                    f:r { { t_ExportDeclaration, clause:[$2, $3], DEFAULT:false, tok } }

    | ! t:export specifier_clause from_clause? asi                                                                        
                                                    f:r { { t_ExportDeclaration, clause:[$2, $3], DEFAULT:false, tok } }

    | t:export variable_statement                                                                           
                                                    f:r { { t_ExportDeclaration, clause:[$2], DEFAULT:false, tok } }

    | ! t:export declaration                                                                                  
                                                    f:r { { t_ExportDeclaration, clause:[$2], DEFAULT:false, tok } }

    | ! t:export t:default hoistable_declaration                                                              
                                                    f:r { { t_ExportDeclaration, clause:[$3], DEFAULT:true, tok } }

    | ! t:export t:default class_declaration                                                                  
                                                    f:r { { t_ExportDeclaration, clause:[$3], DEFAULT:true, tok } }

    | t:export t:default  assignment_expression asi
                                                    f:r { { t_ExportDeclaration, clause:[$3], DEFAULT:true, tok } }

<> export_clause > 

        specifier_clause

    |   namespace

    |   \*                                                            
                                                    f:r {  { t_AmbientExport, tok } }

### Modified Module productions

<> namespace > \* t:as module_binding_identifier                                                              
                                                    f:r { { t_NameSpace, id:$3, tok } }

<> specifier_clause > { specifier(*\, ) ,? }                                                            
                                                    f:r { { t_Specifiers, specifiers:$2, tok } }

<> from_clause > t:from string_literal                                                                    
                                                    f:r { { t_FromClause, url:$2, tok } }

<> specifier > module_binding_identifier                                                                      
                                                    f:r { { t_Specifier, id:$1, tok } }
    | identifier t:as module_binding_identifier                                                                          
                                                    f:r { { t_Specifier, id:$1, as:$3, tok } }                                                                     




############################################################################################################### 
###############################################################################################################
## STATEMENTS
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-Statement
###############################################################################################################

<> statement_list > statement_list_item
                                                    f:r { [ $1 ] }
    | statement_list statement_list_item
                                                    f:r { $1 + $2 }                             

<> statement_list_item > statement 
    | ! declaration


<> statement > ! block_statement 
    |  expression_statement
    | variable_statement
    | continue_statement
    | break_statement
    | throw_statement
    | return_statement
    | debugger_statement
    | labeled_statement
    | empty_statement
    | if_statement
    | breakable_statement
    | with_statement
    | try_statement

<> asi > ( g:rec | \; )

<[ recover asi_1 ] 

    scan back until [ g:nl ] then consume nothing then set prod to asi

    on fail state [ asi_forward_scan ] 

    scan until [ \} $eof ] then consume nothing then set prod to asi
>

<> declaration > class_declaration
    | hoistable_declaration
    | lexical_declaration

<> hoistable_declaration > function_declaration

<> breakable_statement > iteration_statement
    | switch_statement


###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-block
###############################################################################################################

<> block_statement > ! block                          

<> block > ! { statement_list } 
                                                    f:r { { t_BlockStatement, statements:$2, tok } }
    | ! \{  \} 
                                                    f:r { { t_BlockStatement, tok } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-empty-statement
###############################################################################################################

<> empty_statement > ; 
                                                    f:r { { t_EmptyStatement, tok } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-expression-statement
###############################################################################################################

<> expression_statement > expression asi 
                                                    f:r { { t_ExpressionStatement, expression:$1, tok } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-expression-statement
###############################################################################################################

<> if_statement > t:if \( expression \) statement (t:else statement)? 
                                                    f:r { { t_IfStatement, boolean:$3, statement:$5, else:$6, tok } }                

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-iteration-statements
###############################################################################################################

<> iteration_statement > t:do statement t:while \( expression \) asi 
                                                    f:r { { t_DoStatement, statement:$2, boolean:$5, tok } }

    | t:while \( expression \) statement 
                                                    f:r { { t_WhileStatement, boolean:$3, statement:$5, tok } }

    | t:for \( (  
                expression

            |   t:var variable_declaration_list                       
                
                f:r { { t_VariableDeclaration, declarations:$2, tok } }
        )? 

    ; expression? ; expression? \)  statement                                                 
                                                    f:r { { t_ForStatement, init:$3, boolean:$5, iterator:$7, statement:$9,  tok } }

    | t:for \( lexical_declaration expression? ; expression? \) statement                                       
                                                    f:r { { t_ForStatement, init:$3, boolean:$4, iterator:$6, statement:$8, tok } }                                                                           
                                                                                                                                                                                                                                                                    
    | t:for \( (  left_hand_side_expression
        | t:var for_binding                         f:r { { t_VariableDeclaration, declarations:$2, tok }  }
        | for_declaration
    ) t:in expression \) statement                                                                          
                                                    f:r { { t_ForInStatement, init:$3, iterator:$5, statement:$7, tok } } 

    | t:for t:await? \( (  left_hand_side_expression
        | t:var for_binding f:r { { t_VariableDeclaration, declarations:$2, tok }  }
        | for_declaration
    ) t:of expression \) statement                                                                          
                                                    f:r { { t_ForOfStatement, init:$4, iterator:$6, statement:$8, tok, AWAIT:bool($2) } }

<> for_declaration > ( t:let | t:const ) for_binding                                                               
                                                    f:r { { t_LexicalBinding, declarations:$2, symbol:str($1), tok } }

<> for_binding > binding_identifier 
    | binding_pattern 

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-continue-statement
###############################################################################################################

<> continue_statement > t:continue goto_label_identifier? asi                                                    
                                                    f:r { { t_ContinueStatement, label:$2, tok } }  

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-break-statement
###############################################################################################################

<> break_statement > t:break goto_label_identifier? asi
                                                    f:r { { t_BreakStatement, label:$2, tok } }


###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-return-statement
###############################################################################################################

<> return_statement > 
            t:return expression? asi
                                                    f:r { { t_ReturnStatement, expression:$2, tok } }
        |   t:return g:nl
                                                    f:r { { t_ReturnStatement, tok } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-throw-statement
###############################################################################################################

<> throw_statement > t:throw expression asi
                                                    f:r { { t_ThrowStatement, expression:$2, tok } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-with-statement
###############################################################################################################

<> with_statement > t:with \( expression \) statement
                                                    f:r { { t_WithStatement, expression:$3, statement:$5, tok } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-switch-statement
###############################################################################################################

<> switch_statement > t:switch \( expression \) case_block 
                                                    f:r { { t_SwitchStatement, expression:$3, cases:$5, tok } }

<> case_block > { case_clauses? default_clause? case_clauses? } 
                                                    f:r { $2 + [$3] + $4 }

<> case_clauses > case_clause(+)

<> case_clause > t:case expression : statement_list?
                                                    f:r { { t_CaseClause, expression:$2, statements:$4, tok } }

<> default_clause > t:default : statement_list?
                                                    f:r { { t_DefaultClause, statements:$4, tok } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-labeled-statements
###############################################################################################################

<> labeled_statement > label_identifier : labeled_item                                                    
                                                    f:r { { t_LabeledStatement, label:$1, statement:$3, tok } }

<> labeled_item > statement
    | function_declaration

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-try-statement
###############################################################################################################

<> try_statement >  t:try block [ catch? finally? ]
                                                    f:r { { t_TryStatement, block:$2, catch:$3, finally:$4, tok } }

<> catch > t:catch \( catch_parameter \) block
                                                    f:r { { t_CatchClause, parameter:$3, block:$5, tok } }

<> finally > t:finally block
                                                    f:r { { t_FinallyClause, block:$2, tok } }

<> catch_parameter > binding_identifier 
    | binding_pattern

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-debugger-statement
###############################################################################################################

<> debugger_statement > t:debugger asi                                                                         
                                                    f:r { { t_DebuggerStatement, tok } }

###############################################################################################################
###############################################################################################################
## DECLARATIONS
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-variable-statement
###############################################################################################################

<> variable_statement > t:var variable_declaration_list asi
                                                    f:r { { t_VariableStatement, declarations:$2, tok } }

<> variable_declaration_list > variable_declaration(+\, )                                                         

<> variable_declaration > binding_identifier initializer
                                                    f:r=>BindingExpression
    | binding_identifier        
                                    
    | binding_pattern initializer
                                                    f:r => BindingExpression


###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-let-and-const-declarations
###############################################################################################################

<> lexical_declaration > ( t:let | t:const ) binding_list asi
                                                    f:r { { t_LexicalDeclaration, symbol:$1, nodes:$2, tok } }

<> binding_list > lexical_binding(+\, )                                                                            

<> lexical_binding > binding_identifier

    | binding_identifier initializer
                                                    f:r => BindingExpression
    | binding_pattern initializer
                                                    f:r => BindingExpression

###############################################################################################################
###############################################################################################################
## FUNCTIONS
###############################################################################################################
###############################################################################################################

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-function-definitions
###############################################################################################################

## Modified to include async and function generator elements

<> function_declaration > ! t:async? t:function \* ? binding_identifier 
                        \( formal_parameters? \) { function_body? }
                                                    f:r { { t_FunctionDeclaration, ASYNC:bool($1), GENERATOR:bool($3), name:$4, parameters:$6, body:$9, tok } }

<> function_expression > t:async? t:function \* ? binding_identifier? 
                        \( formal_parameters? \) { function_body? }
                                                    f:r { { t_FunctionExpression, ASYNC:bool($1), GENERATOR:bool($3), name:$4, parameters:$6, body:$9, tok } }


<> unique_formal_parameters > formal_parameters

<> formal_parameters > function_rest_parameter
                                                    f:r { { t_FormalParameters, params:[$1], tok } }
    | formal_parameter_list ,?
                                                    f:r { { t_FormalParameters, nodes:$1, tok } }
    | formal_parameter_list , function_rest_parameter
                                                    f:r { { t_FormalParameters, nodes:$1 + [$3], tok } }

<> formal_parameter_list > formal_parameter(+\, )

<> function_rest_parameter > binding_rest_element           

<> formal_parameter > binding_element

<> function_body > function_statement_list

<> function_statement_list > statement_list?

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-GeneratorExpression
###############################################################################################################

<> yield_expression > t:yield g:nl
                                                    f:r { { t_YieldExpression, tok } }
    | t:yield ( \* )? assignment_expression
                                                    f:r { { t_YieldExpression, expression:$3, tok, GENERATOR:bool($2) } }


###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-arrow-function-definitions
###############################################################################################################

<> arrow_function > t:async? arrow_parameters \=> concise_body
                                                    f:r { { t_ArrowFunction, ASYNC:bool($1), parameter:$2, body:$4, tok } }

<> arrow_parameters > identifier_reference
  
    | cover_parenthesized_expression_and_arrow_parameter_list

<> concise_body > (EXC \{ ) assignment_expression 
    | ! { function_statement_list? }
                                                    f:r { { t_BlockStatement, statements: $2, tok } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-async-arrow-function-definitions
###############################################################################################################

<> cover_call_expression_and_async_arrow_head > member_expression arguments                                 
                                                    f:r { { t_CallExpression, reference:$1, arguments:$2, tok } }

###############################################################################################################
###############################################################################################################
## CLASSES
############################################################################################################### 
###############################################################################################################

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-class-definitions
###############################################################################################################

<> class_declaration > ! t:class binding_identifier class_heritage? { class_body? }                           
                                                    f:r { { t_Class, name:$2, heritage:$3, body:$5, tok } }

<> class_expression > t:class binding_identifier? class_heritage? { class_body? }                            
                                                    f:r { { t_Class, name:$2, heritage:$3, body:$5, tok } }

<> class_heritage > t:extends left_hand_side_expression                          

<> class_body >
        
        class_body class_element ;
                                                    f:r { $1 + $2 } 
    |   class_body ;
                                                    f:r { $1 } 
    |   class_element
                                                    f:r { [$1] } 
    |   ;
                                                    f:r { [] }

<> class_element > 

     t:static? method_definition
                                                    f:r { $2.STATIC = bool($1), $2 }

    | t:static? ( \# (EXC g:sp) property_name | property_name ) initializer? asi       

                                                    f:r { $2.STATIC = bool($1), $2 }
    | t:static \{ statement_list \}
                                                    f:r { { t_StaticBlock, statements:$3, tok } }
    


###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-MethodDefinition
###############################################################################################################

<> method_definition > \async ? \* ? property_name \( unique_formal_parameters? \) { function_body? }      
                                                    f:r { { t_Method, ASYNC:bool($1), GENERATOR:bool($2), name:$3, parameters:$5, body:$8, tok } } 

    | \get property_name \( \) { function_body? }                                                           
                                                    f:r { { t_GetterMethod, name:$2, body:$6, tok } }

    | \set property_name \( property_set_parameter_list \) { function_body? }                               
                                                    f:r { { t_SetterMethod, name:$2, parameters:$4, body:$7, tok } }

<> property_set_parameter_list > formal_parameter 

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-comma-operator
###############################################################################################################

<> expression > expression , assignment_expression
                                                    f:r { ( $1 == t_ExpressionList ? ( $1.expressions + $3, $1 )
                                                                : { t_ExpressionList, expressions: [$1, $3], tok } ) }
    | assignment_expression                                                                                 
            
###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-left-hand-side-expressions
###############################################################################################################

<> left_hand_side_expression > new_expression       
    | call_expression         
    | optional_expression                      

<> new_expression > member_expression 

    # | t:new new_expression
    #                                                f:r { { t_NewExpression, nodes:[$2], tok } }

<> member_expression > primary_expression  

    | member_expression \[ expression \]
                                                    f:r { { t_MemberExpression, nodes:[$1, $3], tok, COMPUTED:true } }
    | member_expression . identifier_name
                                                    f:r { ($3.type |= env.cls.PROPERTY_NAME, { t_MemberExpression, nodes:[$1, $3], tok, COMPUTED:false }) }
    | member_expression template_literal
                                                    f:r { { t_CallExpression, nodes:[$1, $2], tok, TEMPLATE:true } }
    | super_property

    | meta_property

    | t:new member_expression arguments
                                                    f:r { { t_NewInstanceExpression, nodes:[$2, $3], tok } }
    | t:new member_expression
                                                    f:r { { t_NewExpression, nodes:[$2], tok } }

<> super_property > t:super . identifier_name
                                                    f:r { ($3.type |= env.cls.PROPERTY_NAME,{ t_SuperExpression, nodes:[$3], tok, COMPUTED:false } ) }
    | t:super \[ expression \]
                                                    f:r { { t_SuperExpression, nodes:[$3], tok, COMPUTED:true } }

<> meta_property > new_target
    | import_meta

##
# 2020 https://262.ecma-international.org/12.0/#prod-ImportMeta
##
<> import_meta > t:import . t:meta
                                                    f:r { { t_ImportMeta, tok } }

<> new_target > t:new . t:target
                                                    f:r { { t_NewTarget, tok } }

<> call_expression > call_expression . identifier_name
                                                    f:r { ($3.type |= env.cls.PROPERTY_NAME,{ t_MemberExpression, nodes:[$1, $3], tok, COMPUTED:false } )}
    | super_call
    | import_call
    | call_expression arguments
                                                    f:r { { t_CallExpression, nodes:[$1, $2], tok, TEMPLATE:false } }
    | call_expression \[ expression \]
                                                    f:r { { t_MemberExpression, nodes:[$1, $3], tok, COMPUTED:true } }
    | cover_call_expression_and_async_arrow_head                                                            
    | call_expression template_literal
                                                    f:r { { t_CallExpression, nodes:[$1, $3], tok, TEMPLATE:true } }

<> super_call > t:super arguments
                                                    f:r { { t_SuperCall, nodes:[$2], tok } }

##
# 2020 https://262.ecma-international.org/12.0/#prod-ImportCall
##
<> import_call > t:import \( assignment_expression \)
                                                    f:r { { t_ImportCall, nodes:[$3], tok } }

<> arguments >  \( argument_list? ,? \)
                                                    f:r { { t_Arguments, nodes:$2 || [], tok } }

<> argument_list > ( assignment_expression | \... assignment_expression f:r=>Spread  )(+\, )

###############################################################################################################
# 2020 https://262.ecma-international.org/12.0/#prod-OptionalExpression
###############################################################################################################
                        
<> optional_expression > member_expression optional_chain
                                                    f:r { { t_OptionalMemberExpression, nodes:[$1, $2.type == "computed" ? $2.val : $2], tok, COMPUTED:$2.type == "computed" } }
    | call_expression optional_chain
                                                    f:r { { t_OptionalMemberExpression, nodes:[$1, $2.type == "computed" ? $2.val : $2], tok, COMPUTED:$2.type == "computed" } }
    | optional_expression optional_chain
                                                    f:r { { t_OptionalMemberExpression, nodes:[$1, $2.type == "computed" ? $2.val : $2], tok, COMPUTED:$2.type == "computed" } }

<> optional_chain > \?. arguments    
                                                                       
    | \?. \[ expression \]  
                                                    f:r { { type:"computed", val:$3 } } 
    | \?. identifier_name  

    | \?. template_literal

    | optional_chain arguments
                                                    f:r { { t_CallExpression, nodes:[$1, $2], tok, TEMPLATE:false } }
    | optional_chain \[ expression \]
                                                    f:r { { t_MemberExpression, nodes:[$1, $3], tok, COMPUTED:true } }
    | optional_chain \. identifier_name
                                                    f:r { ( $3.type |= env.cls.PROPERTY_NAME, { t_MemberExpression, nodes:[$1, $3], tok, COMPUTED:false } ) }
    | optional_chain template_literal
                                                    f:r { { t_CallExpression, nodes:[$1, $2], tok, TEMPLATE:true } }




###############################################################################################################
#https://262.ecma-international.org/12.0/#sec-primary-expression
###############################################################################################################

<> primary_expression > t:this
                                                    f:r { { t_ThisLiteral, tok } }
    | identifier_reference
    | literal
    | array_literal                                             
    | object_literal                                            
    | function_expression
    | class_expression
    | regular_expression_literal
    | template_literal
    | parenthesized
                                                    f:r ^reinterpretParenthesized

#| generator_expression
#| async_function_expression
#| async_generator_expression

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-AwaitExpression
###############################################################################################################

<> await_expression > t:await unary_expression
                                                    f:r { { t_AwaitExpression, nodes:[$2], tok } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-BindingExpression
###############################################################################################################

<> assignment_expression > conditional_expression 

    | yield_expression

    | arrow_function

    | left_hand_side_expression = assignment_expression
                                                    f:r { { t_AssignmentExpression, symbol:"=",  nodes:[$1,$3], tok } }

    | left_hand_side_expression assignment_operator assignment_expression
                                                    f:r { { t_AssignmentExpression, symbol:$2,  nodes:[$1,$3], tok } }

<> assignment_operator > \*=                                                        
    | \/=
    | \%=
    | \+=
    | \-=
    | \<<=
    | \>>=
    | \>>>=
    | \&=
    | \^=
    | \|=
    | \**=
    | \??=
    | \&&=
    | \||=

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-ConditionalExpression
###############################################################################################################

<> conditional_expression > short_circuit_expression
    | short_circuit_expression \? assignment_expression : assignment_expression
                                                    f:r { { t_ConditionalExpression, nodes:[$1, $3, $5], tok } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-binary-logical-operators
###############################################################################################################

<> short_circuit_expression > logical_or_expression

    | coalesce_expression


<> logical_or_expression > logical_and_expression 

    | logical_or_expression \|| logical_and_expression
                                                    f:r { { t_LogicalExpression, symbol:$2, nodes:[$1, $3], tok } }

<> logical_and_expression > bitwise_or_expression 

    | logical_and_expression \&& bitwise_or_expression
                                                    f:r { { t_LogicalExpression, symbol:$2, nodes:[$1, $3], tok } }

##
# 2020 https://262.ecma-international.org/12.0/#prod-CoalesceExpression
##

<> coalesce_expression >  bitwise_or_expression \?? bitwise_or_expression
                                                    f:r { { t_CoalesceExpression, nodes:[$1, $3], tok } }
    | coalesce_expression \?? bitwise_or_expression
                                                    f:r { { t_CoalesceExpression, nodes:[$1, $3], tok } }


###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-binary-bitwise-operators
###############################################################################################################

<> bitwise_or_expression > bitwise_xor_expression 

    | bitwise_or_expression \| bitwise_xor_expression
                                                    f:r { { t_BitwiseExpression, symbol:$2, nodes:[$1, $3], tok } }

<> bitwise_xor_expression > bitwise_and_expression 

    | bitwise_xor_expression \^ bitwise_and_expression
                                                    f:r { { t_BitwiseExpression, symbol:$2, nodes:[$1, $3], tok } }

<> bitwise_and_expression > equality_expression 

    | bitwise_and_expression & equality_expression
                                                    f:r { { t_BitwiseExpression, symbol:$2, nodes:[$1, $3], tok } }

<> equality_expression > relational_expression 

    | equality_expression \== relational_expression
                                                    f:r { { t_EqualityExpression, symbol:$2, nodes:[$1, $3], tok } }
    | equality_expression \!= relational_expression
                                                    f:r { { t_EqualityExpression, symbol:$2, nodes:[$1, $3], tok } }
    | equality_expression \=== relational_expression
                                                    f:r { { t_EqualityExpression, symbol:$2, nodes:[$1, $3], tok } }
    | equality_expression \!== relational_expression
                                                    f:r { { t_EqualityExpression, symbol:$2, nodes:[$1, $3], tok } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-relational-operators
###############################################################################################################

<> relational_expression > shift_expression 

    | relational_expression < shift_expression
                                                    f:r { { t_RelationalExpression, symbol:$2, nodes:[$1, $3], tok } }
    | relational_expression \>  shift_expression
                                                    f:r { { t_RelationalExpression, symbol:$2, nodes:[$1, $3], tok } }
    | relational_expression \<= shift_expression
                                                    f:r { { t_RelationalExpression, symbol:$2, nodes:[$1, $3], tok } }
    | relational_expression \>= shift_expression
                                                    f:r { { t_RelationalExpression, symbol:$2, nodes:[$1, $3], tok } }
    | relational_expression t:instanceof shift_expression
                                                    f:r { { t_InstanceOfExpression,  nodes:[$1, $3], tok } }
    | relational_expression t:in shift_expression
                                                    f:r { { t_InExpression,  nodes:[$1, $3], tok } }   

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-bitwise-shift-operators
###############################################################################################################

<> shift_expression > additive_expression 

    | shift_expression \<< additive_expression
                                                    f:r { { t_ShiftExpression, symbol:$2, nodes:[$1, $3], tok } }
    | shift_expression \>> additive_expression
                                                    f:r { { t_ShiftExpression, symbol:$2, nodes:[$1, $3], tok } }
    | shift_expression \>>> additive_expression
                                                    f:r { { t_ShiftExpression, symbol:$2, nodes:[$1, $3], tok } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-additive-operators
###############################################################################################################

<> additive_expression > multiplicative_expression 

    | additive_expression + multiplicative_expression
                                                    f:r { { t_AdditiveExpression, symbol:$2, nodes:[$1, $3], tok } }
    | additive_expression - multiplicative_expression
                                                    f:r { { t_AdditiveExpression, symbol:$2, nodes:[$1, $3], tok } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-multiplicative-operators
###############################################################################################################

<> multiplicative_expression > exponentiation_expression 

    | multiplicative_expression * exponentiation_expression
                                                    f:r { { t_MultiplicativeExpression, symbol:$2, nodes:[$1, $3], tok } }
    | multiplicative_expression / exponentiation_expression
                                                    f:r { { t_MultiplicativeExpression, symbol:$2, nodes:[$1, $3], tok } }
    | multiplicative_expression % exponentiation_expression
                                                    f:r { { t_MultiplicativeExpression, symbol:$2, nodes:[$1, $3], tok } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-exp-operator
###############################################################################################################

<> exponentiation_expression > unary_expression 

    | update_expression \** exponentiation_expression
                                                    f:r { { t_ExponentiationExpression, nodes:[$1, $3], tok } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-unary-operators
###############################################################################################################

<> unary_expression > update_expression 

    | t:delete unary_expression
                                                    f:r { { t_DeleteExpression, nodes:[$2], tok } }
    | t:void unary_expression
                                                    f:r { { t_VoidExpression, nodes:[$2], tok } }
    | t:typeof unary_expression
                                                    f:r { { t_TypeofExpression, nodes:[$2], tok } }
    | + unary_expression
                                                    f:r { { t_UnaryExpression, symbol:$1, nodes:[$2], tok } }
    | ~ unary_expression
                                                    f:r { { t_UnaryExpression, symbol:$1, nodes:[$2], tok } }
    | \! unary_expression
                                                    f:r { { t_UnaryExpression, symbol:$1, nodes:[$2], tok } }
    | - unary_expression                                                                                    
                                                    f:r { 
                                                        ($2.type == env.typ.NumericLiteral || $2.type == env.typ.BigIntLiteral)
                                                        ? ($2.NEGATIVE = true, $2)
                                                        : ({ t_UnaryExpression, symbol:$1, nodes:[$2], tok }) 
                                                    }
    | await_expression

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-update-expressions
###############################################################################################################

<> update_expression >  left_hand_side_expression 

    | left_hand_side_expression  \++
                                                    f:r { { t_PostExpression, symbol:$2, nodes:[$1], tok } }
    | left_hand_side_expression  \--
                                                    f:r { { t_PostExpression, symbol:$2, nodes:[$1], tok } }
    | \++ unary_expression
                                                    f:r { { t_PreExpression, symbol:$1, nodes:[$2], tok } }
    | \-- unary_expression
                                                    f:r { { t_PreExpression, symbol:$1, nodes:[$2], tok } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-CoverParenthesizedExpressionAndArrowParameterList
###############################################################################################################

<> cover_parenthesized_expression_and_arrow_parameter_list > \( \)
                                                    f:r { { t_Parenthesized, nodes:[], tok } }
    | \( expression , \)
                                                    f:r { { t_Parenthesized, nodes:[$2], tok } }
    | \( ( \... binding_identifier f:r=>Spread)  \)
                                                    f:r { { t_Parenthesized, nodes:[$2], tok } }
    | \( ( \... binding_pattern f:r=>Spread) \)
                                                    f:r { { t_Parenthesized, nodes:[$2], tok } }
    | \( expression , ( \... binding_identifier f:r=>Spread)  \)
                                                    f:r { { t_Parenthesized, nodes:[$2, $4], tok } }
    | \( expression , ( \... binding_pattern f:r=>Spread)  \)
                                                    f:r { { t_Parenthesized, nodes:[$2, $4], tok } }                                                                                       
    | parenthesized                                                                                         

<> parenthesized > \( expression \)
                                                    f:r { { t_Parenthesized, nodes:[$2], tok } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-BindingPattern
###############################################################################################################

<> binding_pattern > object_binding_pattern
    |   array_binding_pattern

<> object_binding_pattern > { }
                                                    f:r { { t_ObjectBinding, nodes:[], tok } }
    | { binding_rest_property }
                                                    f:r { { t_ObjectBinding, nodes:[$2], tok } }
    | { binding_property_list  }
                                                    f:r { { t_ObjectBinding, nodes:[...$2], tok } }    
    | { binding_property_list , binding_rest_property? }
                                                    f:r { { t_ObjectBinding, nodes:[...$2, $4], tok } }    

<> array_binding_pattern >  \[ elision? binding_rest_element? \]
                                                    f:r { { t_ArrayBinding, nodes:[$2, $3], tok } }
    | \[ binding_element_list \]
                                                    f:r { { t_ArrayBinding, nodes:[...$2], tok } }    
    | \[ binding_element_list \, elision? binding_rest_element? \]
                                                    f:r { { t_ArrayBinding, nodes:[...$2, $4, $5], tok } }    

<> binding_property_list > binding_property
                                                    f:r { [$1] }
    | binding_property_list \, binding_property
                                                    f:r { [...$1, $3] }

<> binding_element_list > binding_elision_element                                                           
    | binding_element_list \, binding_elision_element
                                                    f:r { [...$1, ...$3] }

<> binding_elision_element > elision? binding_element
                                                    f:r { [$1, $2] }                                                    

<> binding_property > single_name_binding 
    | property_name : binding_element
                                                    f:r { { t_PropertyBinding, nodes:[$1, $3],  pos  } }  

<> binding_element > single_name_binding
    | binding_pattern initializer?
                                                    f:r { $2 ? { t_BindingExpression, symbol:"=",  nodes: [$1, $2],  pos  } : $1 }

<> single_name_binding > binding_identifier initializer?
                                                    f:r { $2 ? { t_BindingExpression, symbol:"=",  nodes: [$1, $2],  pos  } : $1 }

<> binding_rest_property > \... binding_identifier
                                                    f:r=>Spread
<> binding_rest_element > \... binding_identifier
                                                    f:r=>Spread
    | \... binding_pattern
                                                    f:r=>Spread                                                                                              


###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-object-initializer
###############################################################################################################

<> object_literal >  \{  \}
                                                    f:r { { t_ObjectLiteral, nodes:[],  pos  } }
    | { property_definition_list ,? }
                                                    f:r { { t_ObjectLiteral, nodes:$2,  pos  } }

<> property_definition_list > property_definition
                                                    f:r { [$1] }
    | property_definition_list , property_definition
                                                    f:r { $1.push($3), $1 }       

<> property_definition >  cover_initialized_name                
    | identifier_property_name
                                                    f:r { $1.type |= env.cls.PROPERTY_NAME, $1 }
    | method_definition                                                                                     
    | \... assignment_expression                                                                   f:r =>Spread
    | property_name : assignment_expression
                                                    f:r { { t_PropertyBinding, nodes:[$1, $3],  pos  } }       

<> property_name > literal_property_name
                                                    f:r { $1.type |= env.cls.PROPERTY_NAME, $1 }
    | computed_property_name
                                                    f:r { $1.type |= env.cls.PROPERTY_NAME, $1 }

<> literal_property_name > identifier_property_name                                                                  
    | string_literal
    | numeric_literal

<> computed_property_name > \[ assignment_expression \]
                                                    f:r { { t_ComputedProperty, nodes:[$2], tok } }

<> cover_initialized_name > identifier_property_name initializer
                                                    f:r { 
                                                            $1.type |= env.cls.PROPERTY_NAME, 
                                                            { t_BindingExpression, symbol:"=",  nodes: [$1, $2],  pos  }
                                                    }

<> initializer > = assignment_expression
                                                    f:r { $2 }


###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-array-initializer
###############################################################################################################

<> array_literal > \[ elision? \]
                                                    f:r { { t_ArrayLiteral, nodes:[$2], tok } }
    | \[ element_list \]
                                                    f:r { { t_ArrayLiteral, nodes:$2, tok } }
    | \[ element_list , elision? \]
                                                    f:r { { t_ArrayLiteral, nodes:[...$2, $4], tok } }

<> element_list > elision? assignment_expression
                                                    f:r { [$1, $2 ] }
    | elision? spread_element
                                                    f:r { [ $1,$2 ] }
    | element_list , elision? assignment_expression
                                                    f:r { [ ...$1, $3, $4 ] }
    | element_list , elision? spread_element
                                                    f:r { [ ...$1, $3, $4 ] }

<> elision > ,
                                                    f:r { { t_Elision, count:0, tok } }
    | elision ,
                                                    f:r { { t_Elision, count:$1.count+1, tok } }

<> spread_element > \... assignment_expression      
                                                    f:r=>Spread

###############################################################################################################
# https://262.ecma-international.org/12.0/#prod-RegularExpressionLiteral
###############################################################################################################

<> regular_expression_literal > \/ (g:nl | g:sp | g:sym | g:num | g:id | escaped_sequence | \\/ )(*\" ) \/ def::js_identifier?
                                                    f:r { { t_RegexLiteral, value:$2, flags:$4,  pos  } }

<> regular_expression_flags > identifier_name  

###############################################################################################################
#https://262.ecma-international.org/12.0/#prod-TemplateLiteral
###############################################################################################################

<> template_literal > no_substitute_template
    | substitute_template 

<> no_substitute_template > \` tk:template_string? \`                                            
                                                    f:r { { t_Template, nodes:[ { quote_type:"", t_StringLiteral, value:$2,  pos  }], NO_SUBSTITUTE:true, tok } }

<> substitute_template > template_head expression template_spans                                            
                                                    f:r { $3.unshift($1, $2), { t_Template, nodes:$3, tok } }

<> template_spans > template_tail                                                                           
                                                    f:r { [ $1 ] }
    | template_middle_list template_tail                                                                    
                                                    f:r { $1.push($2), $1 }           

<> template_middle_list > template_middle expression                                                        
                                                    f:r { [ $1, $2 ] }
    | template_middle_list template_middle expression                                                       
                                                    f:r { $1.push($2, $3), $1 }

<> template_head >       \` (RST g:sp g:nl tk:comment) tk:template_string? \${                                                             
                                                    f:r { { t_TemplateHead, value:$2 || "", tok  } }

<> template_middle >    \} (RST g:sp g:nl tk:comment) tk:template_string? \${                                                             
                                                    f:r { { t_TemplateMiddle, value:$2 || "",  pos  } }

<> template_tail >      \} (RST g:sp g:nl tk:comment) tk:template_string? \`                                                               
                                                    f:r { { t_TemplateTail, value:$2 || "",  pos  } }

<> template_string > template_string_data(+\" ) (  ?=\` | ?=\${  ) 

<> template_string_data >  g:nl | g:sp | g:sym | g:num | g:id | template_escaped_sequence  


<> template_escaped_sequence > \\ ( g:sp | g:sym | g:num | g:id ) f:r { $1 + $2}


###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-ecmascript-language-lexical-grammar
###############################################################################################################

<> literal > boolean_literal                
    | null_literal
    | string_literal                    
    | numeric_literal    

<> string_literal > 

        \" (RST g:sp g:nl tk:comment) tk:double_quote_string_data? \"
                                                    f:r { { quote_type:$1, t_StringLiteral, value:str($2),  pos  } }

    |   \' (RST g:sp g:nl tk:comment) tk:single_quote_string_data? \'
                                                    f:r { { quote_type:$1, t_StringLiteral, value:str($2),  pos  } }

<> single_quote_string_data > ( \" | g:nl | g:sp | g:sym | g:num | g:id | escaped_sequence )(*) ?=\' 

<> double_quote_string_data > ( \' | g:nl | g:sp | g:sym | g:num | g:id | escaped_sequence )(*) ?=\"
                   

<> escaped_sequence > \\ ( g:nl | g:sp | g:sym | g:num | g:id  )

<> numeric_literal > scientific_token
                                                    f:r { { t_NumericLiteral, value:$1, computed_value:f64($1)), tok, NEGATIVE:false } }
    | big_token
                                                    f:r { { t_BigIntLiteral, value:$1, computed_value:f64($1)), tok, NEGATIVE:false } }
    | hex_token
                                                    f:r { { t_NumericLiteral, value:$1, computed_value:f64($1)), tok, NEGATIVE:false } }
    | octal_token
                                                    f:r { { t_NumericLiteral, value:$1, computed_value:f64($1)), tok, NEGATIVE:false } }
    | binary_token
                                                    f:r { { t_NumericLiteral, value:$1, computed_value:f64($1)), tok, NEGATIVE:false } }


<> big_token >  int_token (RST g:sp g:nl) t:n                                                                                
                                                    f:r { $1 }
                                                                                                      
<> scientific_token > float_token ( (\e | \E ) \- ? int_token f:r { $1 + $2 + $3} )?                        
                                                    f:r {$1+$2}

<> float_token > int_token ( \. int_token f:r { $1 + $2} )?                                                 
                                                    f:r { $1 + $2}

<> int_token > g:num ( \_  g:num f:r { $1 + $2}  )(*\" )                                                    
                                                    f:r { $1 + $2}                                                                

<> hex_token > ( \0x | \0X ) ( g:num | \a | \b | \c | \d | \e | \f | \A | \B | \C | \D | \E | \F )(+\" ) 
                                ( \_ ( g:num | \a | \b | \c | \d | \e | \f | \A | \B | \C | \D | \E | \F )(+\" ) f:r {$1+$2} )(*\" )

                                                    f:r { $1 + $2 + $3}   

<> binary_token > ( \0b | \0B ) ( \0 | \1 )(+\" ) ( \_ ( \0 | \1 )(+\" ) f:r {$1+$2} )(*\" )                            
                                                    f:r { $1 + $2 + $3}   

<> octal_token > ( \0o | \0O ) ( \0 | \1 | \2 | \3 | \4 | \5 | \6 | \7 )(+\" ) ( \_ ( \0 | \1 | \2 | \3 | \4 | \5 | \6 | \7 )(+\" ) f:r {$1+$2} )(*\" )
                                                    f:r { $1 + $2 + $3}   

<> null_literal >  t:null
                                                    f:r { { t_NullLiteral, tok  } }

<> undefined_literal >  t:undefined
                                                    f:r { { t_Undefined, tok  } }

<> boolean_literal > t:true
                                                    f:r { { t_BooleanLiteral, value: $1,  pos  } }
    | t:false
                                                    f:r { { t_BooleanLiteral, value: $1,  pos  } }

###############################################################################################################
# https://262.ecma-international.org/12.0/#sec-names-and-keywords
###############################################################################################################

<> imported_default_binding > tk:composite_identifier                                                              
                                                    f:r { {IdentifierDefault, value:$1, tok } }

<> module_binding_identifier > tk:composite_identifier                                                                            
                                                    f:r { {IdentifierModule, value:$1, tok } }

<> label_identifier > tk:composite_identifier
                                                    f:r { {t_IdentifierLabel, value:$1, tok } }

<> goto_label_identifier > label_identifier
                                                    f:r { {t_IdentifierLabel, value:$1, tok } }

<> identifier_reference > tk:composite_identifier
                                                    f:r { {t_IdentifierReference, value:$1,pos } }

<> binding_identifier > tk:composite_identifier
                                                    f:r { {t_IdentifierBinding, value:$1, tok } }

<> identifier >  tk:composite_identifier
                                                    f:r { { t_Identifier, value:$1,  pos  } }   

<> identifier_property_name > tk:composite_identifier 
                                                    f:r { { t_IdentifierName, value:$1,  pos  } }         

<> identifier_name > tk:composite_identifier 
                                                    f:r { { t_IdentifierName, value:$1,  pos  } }                                     
                                                                                                          
<> composite_identifier > composite_identifier (RST g:sp g:nl) g:id
    | composite_identifier (RST g:sp g:nl) \_
    | composite_identifier (RST g:sp g:nl) \$
    | composite_identifier (RST g:sp g:nl) g:num
    | \_ 
    | \$ 
    | g:id

# Keywords are implied when the t: operator is used to define a 
# terminal.
